import { Op } from "sequelize"; // импортируем Op из sequelize для сложных условий и поиска
import models from "../models/models.js";

class ProductController {

    // первым параметром эти функции принимают req(запрос),а вторым параметром res(ответ),третьим параметром передаем функцию next(следующий по цепочке middleware,в данном случае это наш errorMiddleware)
    async getProducts(req, res, next) {

        // отличие req.params от req.query заключается в том,что в req.params указываются параметры в самом url до эндпоинта на бэкэнде(в node js в данном случае,типа /api/getProducts) через :(типа /:id,динамический параметр id),а req.query - это параметры,которые берутся из url(которые дополнительно добавили с фронтенда к url) через знак ?(типа ?name=bob)

        try {

            const { categoryId, tasteId } = req.query; // берем из параметров запроса поля categoryId и tasteId

            let products; // указываем переменную для массива объектов товаров,указываем ей let,чтобы можно было изменять ей значение

            // если categoryId false(или null) и tasteId false(или null),то есть эти параметры не указаны или равны пустому значению
            if (!categoryId && !tasteId) {

                products = await models.Product.findAll(); // помещаем в переменную products все записи(объекты) из базы данных postgreSql у таблицы Product с помощью функции findAll()

            }

            // если categoryId true,то есть в categoryId есть какое-то значение,то изменяем переменную products на все товары,отфильтрованные по categoryId(по категории)
            if (categoryId) {

                products = await models.Product.findAll({ where: { categoryId: categoryId } }); // помещаем в переменную products все записи(объекты) из базы данных postgreSql у таблицы Product с помощью функции findAll(),указываем условие с помощью where и указываем,что берем все объекты из таблицы Product где categoryId равно параметру categoryId,который взяли из параметров запроса
            }

            return res.json(products); // возвращаем массив товаров(products) на клиент после всех проверок выше


        } catch (e) {
            console.log(e);
        }
    }


    async getProductsCatalog(req, res) {

        try {

            const { categoryId, tasteId, name } = req.query; // берем из параметров запроса поля categoryId и tasteId

            let categoryObj; // указываем переменную для объекта категории,укаызаем ей let,чтобы потом изменять ее значение

            // если categoryId true(то есть в параметре categoryId есть какое-то значение,то указываем значение переменной categoryObj как объект с полем categoryId и значением параметра categoryId(который мы взяли из url),в другом случае указываем значение переменной categoryObj как null,это делаем,чтобы проверить,указан ли categoryId,и если нет,то указываем этой переменной значение null,и потом эту переменную(этот объект) categoryObj разворачиваем в условии для получения объектов товаров из базы данных postgreSql ниже в коде)
            if (categoryId) {
                categoryObj = {
                    categoryId: categoryId
                }
            } else {
                categoryObj = null;
            }


            let products;


            products = await models.Product.findAll({
                where: {
                    name: {
                        [Op.iLike]: `%${name}%` // указываем у Op метод iLike(он нужен для поиска по полю объектов в базе данных postgreSql,он ищет похожие совпадения по значениям,которые равны в данном случае параметру name(этот параметр мы получили из url от фронтенда,этот параметр с фронтенда мы передаем в этот параметр значение инпута поиска),который мы указали потом через двоеточие),указываем знаки процента перед поисковым параметром name(в данном случае) и после поискового параметра,это значит,что не важно в каком порядке будет написана буква или слово,оно будет просто проверяться,есть ли такая буква у поля объекта или нет(то есть как и нам нужно для поиска),если не указывать эти знаки процента,то поиск будет осуществляться только по полным значениям поля объекта и по конкретному порядку букв и слов у поля объекта( то есть символ процента % означает, что на этом месте может быть что угодно – один символ или сотня, или ни одного ),есть также метод like у Op,но он отличается от iLike тем,что в iLike не важен регистр букв(то есть не важно,заглавные буквы будут или маленькие),а в методе like соблюдается регистр букв,и если будут введены,например,какие-то заглавные буквы,то такие же маленькие буквы у поля объекта не будут находится,также у Op(оператора sequelize) есть другие методы и операторы типа and,or, between(сравнение чисел,типа [Op.between]:[8,10], число между 8 и 10), Op.gt(больше определенного числа,типа [Op.gt]:5, больше 5), Op.in(проверяет,содержится ли значение в конкретном списке значений,типа вместо оператора or, например, [Op.in]:[1,2,3], то есть содержится ли значение поля в хотя бы одном значении элемента этого массива чисел) и тд(можно посмотреть в интернете отдельно) 
                    },
                    
                    ...categoryObj // разворачиваем объект categoryObj(вместо этого будет подставлено categoryId:categoryId,если проверка выше на categoryId была true,если была false,то тут будет null)

                }
            });



            return res.json(products); // возвращаем массив товаров(products) на клиент после всех проверок выше


        } catch (e) {
            console.log(e);
        }

    }

}

export default new ProductController(); // экспортируем объект на основе класса ProductController